<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Formal Methods for Security Gate Patterns</title>
<link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,300;0,400;0,500;0,600;1,400&family=JetBrains+Mono:wght@400;500&family=Source+Sans+3:wght@300;400;500;600&display=swap" rel="stylesheet">
<style>
  :root {
    --ink: #1a1a1a;
    --ink-light: #4a4a4a;
    --ink-faint: #7a7a7a;
    --paper: #fdfbf7;
    --paper-warm: #f5f0e8;
    --accent: #8b2500;
    --accent-light: #c44d2a;
    --rule: #c8bfb0;
    --math-bg: #f8f5ef;
    --blue: #1a4a6e;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  html {
    font-size: 17px;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  body {
    font-family: 'Crimson Pro', Georgia, serif;
    color: var(--ink);
    background: var(--paper);
    line-height: 1.72;
    padding: 0;
  }

  .page {
    max-width: 740px;
    margin: 0 auto;
    padding: 4rem 2rem 6rem;
  }

  header {
    margin-bottom: 3.5rem;
    padding-bottom: 2rem;
    border-bottom: 2px solid var(--ink);
  }

  header h1 {
    font-family: 'Source Sans 3', Helvetica, sans-serif;
    font-weight: 600;
    font-size: 2rem;
    letter-spacing: -0.02em;
    line-height: 1.2;
    color: var(--ink);
    margin-bottom: 0.4rem;
  }

  header .subtitle {
    font-family: 'Source Sans 3', Helvetica, sans-serif;
    font-weight: 300;
    font-size: 1.15rem;
    color: var(--ink-light);
    margin-bottom: 1.6rem;
  }

  header .meta {
    font-family: 'Source Sans 3', Helvetica, sans-serif;
    font-size: 0.85rem;
    font-weight: 400;
    color: var(--ink-faint);
    line-height: 1.7;
  }

  header .meta a {
    color: var(--blue);
    text-decoration: none;
  }

  header .meta a:hover {
    text-decoration: underline;
  }

  .section {
    margin-bottom: 3rem;
  }

  h2 {
    font-family: 'Source Sans 3', Helvetica, sans-serif;
    font-weight: 600;
    font-size: 1.35rem;
    color: var(--ink);
    margin-bottom: 0.3rem;
    padding-top: 1rem;
    letter-spacing: -0.01em;
  }

  h2 .num {
    color: var(--accent);
    margin-right: 0.3em;
  }

  h3 {
    font-family: 'Source Sans 3', Helvetica, sans-serif;
    font-weight: 500;
    color: var(--ink-light);
    margin-top: 2rem;
    margin-bottom: 0.6rem;
    text-transform: uppercase;
    letter-spacing: 0.06em;
    font-size: 0.82rem;
  }

  p {
    margin-bottom: 0.9rem;
    text-align: justify;
    hyphens: auto;
  }

  .separator {
    border: none;
    border-top: 1px solid var(--rule);
    margin: 2.5rem 0;
  }

  .math-block {
    background: var(--math-bg);
    border-left: 3px solid var(--accent);
    padding: 1.2rem 1.5rem;
    margin: 1.2rem 0 1.4rem;
    border-radius: 0 4px 4px 0;
    overflow-x: auto;
  }

  .math-block code {
    font-family: 'JetBrains Mono', 'Menlo', monospace;
    font-size: 0.82rem;
    line-height: 1.85;
    color: var(--ink);
    white-space: pre;
    display: block;
  }

  .m {
    font-family: 'JetBrains Mono', 'Menlo', monospace;
    font-size: 0.88em;
    color: var(--ink);
    background: var(--math-bg);
    padding: 0.1em 0.3em;
    border-radius: 3px;
  }

  .theorem {
    background: var(--paper-warm);
    border: 1px solid var(--rule);
    border-radius: 4px;
    padding: 1.2rem 1.5rem;
    margin: 1.4rem 0;
  }

  .theorem .label {
    font-family: 'Source Sans 3', Helvetica, sans-serif;
    font-weight: 600;
    font-size: 0.82rem;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    color: var(--accent);
    margin-bottom: 0.5rem;
  }

  .theorem p {
    margin-bottom: 0.5rem;
  }

  .theorem p:last-child {
    margin-bottom: 0;
  }

  .qed {
    float: right;
    color: var(--accent);
    font-size: 0.9em;
  }

  .proof {
    margin: 0.8rem 0 1.2rem;
    padding-left: 1rem;
    border-left: 2px solid var(--rule);
  }

  .proof .tag {
    font-style: italic;
    color: var(--ink-light);
    font-size: 0.95rem;
  }

  .notation-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 0 2rem;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.8rem;
    line-height: 2;
    margin: 1rem 0;
    padding: 1rem 1.5rem;
    background: var(--math-bg);
    border-radius: 4px;
  }

  .notation-grid .entry {
    display: flex;
    gap: 0.8rem;
  }

  .notation-grid .sym {
    color: var(--accent);
    min-width: 2.2rem;
    text-align: center;
    flex-shrink: 0;
  }

  .notation-grid .def {
    color: var(--ink-light);
    font-family: 'Source Sans 3', sans-serif;
    font-size: 0.82rem;
  }

  footer.page-footer {
    margin-top: 3rem;
    padding-top: 1.5rem;
    border-top: 1px solid var(--rule);
    font-family: 'Source Sans 3', Helvetica, sans-serif;
    font-size: 0.8rem;
    color: var(--ink-faint);
    text-align: center;
  }

  footer.page-footer a {
    color: var(--blue);
    text-decoration: none;
  }

  footer.page-footer a:hover {
    text-decoration: underline;
  }

  @media print {
    body { background: white; font-size: 11pt; }
    .page { padding: 0; max-width: 100%; }
    .math-block { background: #f5f5f5; break-inside: avoid; }
    .theorem { break-inside: avoid; }
    header { break-after: avoid; }
  }

  @media (max-width: 600px) {
    html { font-size: 15px; }
    .page { padding: 2rem 1.2rem 3rem; }
    .notation-grid { grid-template-columns: 1fr; }
  }
</style>
</head>
<body>
<div class="page">

<header>
  <h1>Formal Methods for Security Gate Patterns</h1>
  <div class="subtitle">Mathematical Foundations for CVE-Surface Reduction</div>
  <div class="meta">
    Author: Euman Engineer<br>
    Contact: <a href="mailto:opsec.ee@pm.me">opsec.ee@pm.me</a><br>
    February 2025<br>
    License: CC BY-NC 4.0 ‚Äî <a href="https://github.com/opsec-ee/euman-scanner/blob/main/LICENSE">https://github.com/opsec-ee/euman-scanner/blob/main/LICENSE</a>
  </div>
</header>

<!-- ¬ß1 -->
<div class="section">
<h2><span class="num">1</span> Gate Predicate Logic</h2>

<p>Let <span class="m">S</span> be the set of all observable program states. Let <span class="m">Œ© = { 0, 1, X, Z }</span> be the 4-state gate output domain:</p>

<div class="math-block"><code>0 ‚â° PASS       precondition satisfied
1 ‚â° FAIL       violation detected
X ‚â° UNKNOWN    insufficient information to decide
Z ‚â° INVALID    gate inputs themselves are corrupt</code></div>

<p>A gate <span class="m">G</span> is a total function <span class="m">G : S ‚Üí Œ©</span> satisfying the totality requirement <span class="m">‚àÄs ‚àà S : G(s) ‚àà Œ©</span>. No gate may be partial. If the gate cannot evaluate, it returns X or Z ‚Äî never ‚ä•.</p>

<h3>Gate Class Predicates</h3>

<p>Let <span class="m">ptr ‚àà Addr</span>, <span class="m">rc ‚àà ‚Ñï</span>, <span class="m">buf ‚àà Byte*</span>, <span class="m">œÑ ‚àà Type</span>, <span class="m">t ‚àà Time</span>.</p>

<div class="math-block"><code>œÜ_UAF(ptr)    ‚â°  ptr ‚àà Live  ‚àß  rc(ptr) &gt; 0
œÜ_DF(ptr)     ‚â°  ptr ‚àà Live  ‚àß  freed(ptr) = false
œÜ_NUL(ptr)    ‚â°  ptr ‚â† 0x0   ‚àß  page(ptr) ‚àà Mapped
œÜ_BOF(buf, i) ‚â°  0 ‚â§ i &lt; len(buf)
œÜ_TYP(ptr, œÑ) ‚â°  typeof(ptr) ‚äë œÑ
œÜ_RAC(r, t)   ‚â°  ¬¨‚àÉt‚Ä≤ ‚àà (t_check, t_use) : mut(r, t‚Ä≤)
œÜ_REF(rc)     ‚â°  rc &lt; RC_MAX  ‚àß  rc ‚â• 0</code></div>

<p>Gate evaluation:</p>

<div class="math-block"><code>         ‚éß 0   if œÜ(s) = true
         ‚é™ 1   if œÜ(s) = false
G(s)  =  ‚é® X   if œÜ(s) is undecidable at runtime
         ‚é™ Z   if inputs to œÜ are themselves corrupt
         ‚é©</code></div>

<h3>Universal Invariant</h3>

<p>For any function <span class="m">f</span> protected by gate set <span class="m">Œì = {G‚ÇÅ, ‚Ä¶, G‚Çô}</span>:</p>

<div class="math-block"><code>pre(f) ‚â° ‚ãÄ·µ¢‚Çå‚ÇÅ‚Åø (G·µ¢(s) = 0)</code></div>

<p>Execution of <span class="m">f</span> proceeds if and only if all gates pass.</p>

<h3>Composition Algebra</h3>

<p>Gate conjunction, where <span class="m">‚ñ∑</span> denotes sequential check:</p>

<div class="math-block"><code>(G‚ÇÅ ‚ñ∑ G‚ÇÇ)(s) = G‚ÇÅ(s)    if G‚ÇÅ(s) ‚â† 0
              = G‚ÇÇ(s)    if G‚ÇÅ(s) = 0

Short-circuit:
  G‚ÇÅ(s) = 1  ‚üπ  (G‚ÇÅ ‚ñ∑ G‚ÇÇ)(s) = 1      fail-fast
  G‚ÇÅ(s) = Z  ‚üπ  (G‚ÇÅ ‚ñ∑ G‚ÇÇ)(s) = Z      corruption propagates</code></div>

<p>Ordering on <span class="m">Œ©</span> (failure lattice): <span class="m">Z &gt; 1 &gt; X &gt; 0</span>. For a gate vector <span class="m">Œì = ‚ü®G‚ÇÅ, ‚Ä¶, G‚Çô‚ü©</span>:</p>

<div class="math-block"><code>Œì(s) = max(G‚ÇÅ(s), G‚ÇÇ(s), ‚Ä¶, G‚Çô(s))</code></div>

<p>The worst violation dominates.</p>
</div>

<hr class="separator">

<!-- ¬ß2 -->
<div class="section">
<h2><span class="num">2</span> Object Lifetime State Machine</h2>

<p>Use-after-free and double-free are illegal transitions in the object lifecycle. Gates enforce transition guards.</p>

<h3>Definition</h3>

<div class="math-block"><code>M = (Q, Œ£, Œ¥, q‚ÇÄ, F)

Q  = { A, R, D, F, ‚ä• }

  A = Allocated       memory obtained, not yet referenced
  R = Referenced      at least one live reference exists
  D = Dereferenced    all references released, rc = 0
  F = Freed           memory returned to allocator
  ‚ä• = Error           illegal state ‚Äî vulnerability triggered

q‚ÇÄ = A       initial state
F  = { F }   accepting states
‚ä• absorbing  no transitions out

Œ£  = { alloc, ref, deref, free, access }</code></div>

<h3>Transition Function Œ¥ : Q √ó Œ£ ‚Üí Q</h3>

<div class="math-block"><code>Œ¥(A, ref)    = R
Œ¥(A, free)   = F
Œ¥(A, deref)  = ‚ä•
Œ¥(A, access) = ‚ä•

Œ¥(R, ref)    = R            rc ‚Üê rc + 1
Œ¥(R, deref)  = R            if rc ‚àí 1 &gt; 0
Œ¥(R, deref)  = D            if rc ‚àí 1 = 0
Œ¥(R, access) = R
Œ¥(R, free)   = ‚ä•            UAF-001 / CWE-416

Œ¥(D, free)   = F
Œ¥(D, ref)    = ‚ä•
Œ¥(D, deref)  = ‚ä•
Œ¥(D, access) = ‚ä•            UAF-001 / CWE-416

Œ¥(F, alloc)  = A‚Ä≤           reallocation
Œ¥(F, ref)    = ‚ä•            UAF-001 / CWE-416
Œ¥(F, access) = ‚ä•            UAF-001 / CWE-416
Œ¥(F, free)   = ‚ä•            DF-001  / CWE-415

Œ¥(‚ä•, œÉ)     = ‚ä•            ‚àÄœÉ ‚àà Œ£</code></div>

<h3>Gate as Transition Guard</h3>

<p>For any transition <span class="m">Œ¥(q, œÉ)</span> where <span class="m">Œ¥(q, œÉ)</span> could reach ‚ä•:</p>

<div class="math-block"><code>Œ¥_guarded(q, œÉ) = Œ¥(q, œÉ)     if G_œÉ(s) = 0
                = q             if G_œÉ(s) ‚â† 0     block and log</code></div>

<div class="theorem">
  <div class="label">Safety Theorem</div>
  <p>If every transition into ‚ä• is guarded by a gate <span class="m">G</span> where <span class="m">G(s)</span> is evaluated before <span class="m">Œ¥</span>, then <span class="m">‚àÄ</span> reachable states <span class="m">q : q ‚â† ‚ä•</span>.</p>
</div>

<div class="proof">
  <p><span class="tag">Proof.</span> By induction on transition sequences. Base case: <span class="m">q‚ÇÄ = A ‚â† ‚ä•</span>. Inductive step: assume <span class="m">q‚Çô ‚â† ‚ä•</span>. If <span class="m">Œ¥(q‚Çô, œÉ) = ‚ä•</span>, then <span class="m">G_œÉ</span> fires and the transition is blocked, so <span class="m">q‚Çô‚Çä‚ÇÅ = q‚Çô ‚â† ‚ä•</span>. <span class="qed">‚àé</span></p>
</div>

<h3>Refcount Invariant</h3>

<p>For any object <span class="m">o</span> with reference count <span class="m">rc(o)</span>:</p>

<div class="math-block"><code>INV_REF(o)  ‚â°  0 ‚â§ rc(o) ‚â§ RC_MAX       where RC_MAX = 2¬≥¬π ‚àí 1

REF-001 gate enforces:

  pre(ref)   :  rc(o) &lt; RC_MAX            overflow prevention
  pre(deref) :  rc(o) &gt; 0                 underflow prevention
  pre(free)  :  rc(o) = 0  ‚àß  state(o) = D</code></div>

<h3>Bijective Contract</h3>

<p>For a function <span class="m">f : X ‚Üí Y</span> protected by gate <span class="m">G</span>:</p>

<div class="math-block"><code>{ G(s) = 0 }  f(x)  { G(s‚Ä≤) = 0 }</code></div>

<p>If the gate passes before <span class="m">f</span> and <span class="m">f</span> preserves the invariant, then the gate passes after <span class="m">f</span>. This is the gate stability property ‚Äî correct code cannot cause a gate to spontaneously transition from PASS to FAIL.</p>
</div>

<hr class="separator">

<!-- ¬ß3 -->
<div class="section">
<h2><span class="num">3</span> TOCTOU / RACE-001 Temporal Logic</h2>

<p>Race conditions require reasoning over time. We formalize using linear temporal logic over discrete execution steps.</p>

<h3>Temporal Model</h3>

<p>Let <span class="m">T = ‚ü®t‚ÇÄ, t‚ÇÅ, t‚ÇÇ, ‚Ä¶‚ü©</span> be a discrete timeline of execution steps across all threads. For resource <span class="m">r</span>:</p>

<div class="math-block"><code>val(r, t) = value of r at time t
mut(r, t) = true iff r is mutated at time t</code></div>

<h3>TOCTOU Window</h3>

<p>A check-use pair <span class="m">(c, u)</span> on resource <span class="m">r</span> defines:</p>

<div class="math-block"><code>W(c, u) = { t ‚àà T : t_c &lt; t &lt; t_u }</code></div>

<p>TOCTOU safety predicate:</p>

<div class="math-block"><code>SAFE(r, c, u)  ‚â°  ‚àÄt ‚àà W(c, u) : ¬¨mut(r, t)</code></div>

<p>No mutation of <span class="m">r</span> occurs between check and use. The RACE-001 gate: <span class="m">œÜ_RAC(r, c, u) = SAFE(r, c, u)</span>.</p>

<h3>LTL Specification</h3>

<p>Let <span class="m">p</span> = resource <span class="m">r</span> has been checked, <span class="m">q</span> = resource <span class="m">r</span> is used, <span class="m">m</span> = resource <span class="m">r</span> is mutated.</p>

<p>Safety property:</p>

<div class="math-block"><code>‚ñ°(p ‚Üí (¬¨m U q))</code></div>

<p>Globally, if <span class="m">r</span> is checked, then <span class="m">r</span> is not mutated until <span class="m">r</span> is used.</p>

<p>Violation witness:</p>

<div class="math-block"><code>‚óá(p ‚àß ‚óá(m ‚àß ¬¨q ‚àß ‚óáq))</code></div>

<p>Eventually <span class="m">r</span> is checked, then eventually mutated before being used, and then used with stale data.</p>

<h3>Window Contraction Theorem</h3>

<div class="math-block"><code>P(race) ‚àù |W(c, u)| √ó f_mut(r)

  |W(c, u)| = t_u ‚àí t_c           window width in cycles
  f_mut(r)  = mutations/cycle      mutation frequency</code></div>

<p>To minimize <span class="m">P(race)</span>:</p>

<div class="math-block"><code>Strategy 1:  Minimize |W|            check immediately before use
Strategy 2:  Lock r during W         mutex eliminates f_mut
Strategy 3:  REAR verification       detect post-hoc</code></div>

<p>The REAR sidecar implements Strategy 3: <span class="m">REAR asserts val(r, t_c) = val(r, t_u)</span>. If violated, RACE-001 fires retroactively.</p>

<h3>Interleaving Semantics</h3>

<p>Let <span class="m">Œò = {Œ∏‚ÇÅ, Œ∏‚ÇÇ, ‚Ä¶, Œ∏‚Çô}</span> be the set of active threads. An execution trace <span class="m">œÉ</span> is an interleaving <span class="m">œÉ ‚àà shuffle(Œ∏‚ÇÅ, Œ∏‚ÇÇ, ‚Ä¶, Œ∏‚Çô)</span>.</p>

<p>RACE-001 is violated iff:</p>

<div class="math-block"><code>‚àÉœÉ ‚àà Interleavings(Œò) :
    ‚àÉ(c, u) ‚àà œÉ|Œ∏·µ¢,  ‚àÉm ‚àà œÉ|Œ∏‚±º  (i ‚â† j) :
        t_c &lt; t_m &lt; t_u  ‚àß  target(m) = target(c)</code></div>

<p>There exists an interleaving where another thread mutates the checked resource before the checking thread uses it.</p>

<p>Gate coverage: a gate set <span class="m">Œì</span> is RACE-COMPLETE for resource set <span class="m">R</span> iff:</p>

<div class="math-block"><code>‚àÄr ‚àà R, ‚àÄ(c, u) on r :  ‚àÉG ‚àà Œì : G validates SAFE(r, c, u)</code></div>
</div>

<hr class="separator">

<!-- ¬ß4 -->
<div class="section">
<h2><span class="num">4</span> Overhead Cost Model</h2>

<p>Security levels form a lattice. Gate activation is monotonic over this lattice. The compile-out property guarantees zero cost at the bottom.</p>

<h3>Security Level Lattice</h3>

<p>Let <span class="m">L = { NONE, BASIC, STANDARD, PARANOID }</span> ordered by ‚äë :</p>

<div class="math-block"><code>NONE  ‚äë  BASIC  ‚äë  STANDARD  ‚äë  PARANOID</code></div>

<p><span class="m">L</span> forms a total order and therefore a lattice with <span class="m">‚äì = min</span>, <span class="m">‚äî = max</span>.</p>

<h3>Gate Activation Function</h3>

<p>Let <span class="m">ùí¢ = {UAF, DF, NULL, BOF, TYPE, RACE, REF}</span> be all gate classes. Define activation <span class="m">Œ± : L ‚Üí ùí´(ùí¢)</span> :</p>

<div class="math-block"><code>Œ±(NONE)     = ‚àÖ
Œ±(BASIC)    = { REF, TYPE }
Œ±(STANDARD) = { REF, TYPE, BOF, NULL }
Œ±(PARANOID) = ùí¢                          all gates plus canaries</code></div>

<p>Monotonicity: <span class="m">l‚ÇÅ ‚äë l‚ÇÇ ‚üπ Œ±(l‚ÇÅ) ‚äÜ Œ±(l‚ÇÇ)</span>. Higher security levels only add gates, never remove them.</p>

<h3>Cost Function</h3>

<p>Each gate <span class="m">G·µ¢</span> has a per-invocation cost <span class="m">c·µ¢</span> measured in branch-on-condition cycles. For a function <span class="m">f</span> invoked with frequency <span class="m">f·µ¢</span> calls/sec, guarded by gate set <span class="m">Œì_f ‚äÜ ùí¢</span> :</p>

<div class="math-block"><code>Cost(f, l) = f·µ¢  √ó  Œ£{ c‚±º : G‚±º ‚àà Œì_f ‚à© Œ±(l) }

Overhead(l) = Œ£_f Cost(f, l)  /  Baseline</code></div>

<p>Measured bounds:</p>

<div class="math-block"><code>Overhead(NONE)      =  0%         proven below
Overhead(BASIC)     ‚âà  5%         REF + TYPE only
Overhead(STANDARD)  ‚âà 10%         plus bounds checks
Overhead(PARANOID)  ‚âà 20%         all gates plus memory canaries</code></div>

<div class="theorem">
  <div class="label">Compile-Out Theorem</div>
  <p><strong>Claim:</strong> <span class="m">Overhead(NONE) = 0</span> exactly.</p>
</div>

<div class="proof">
  <p><span class="tag">Proof.</span> <span class="m">Œ±(NONE) = ‚àÖ</span> by definition. <span class="m">‚üπ ‚àÄf : Œì_f ‚à© Œ±(NONE) = ‚àÖ</span> (intersection with ‚àÖ). <span class="m">‚üπ ‚àÄf : Cost(f, NONE) = 0</span> (empty sum). <span class="m">‚üπ Overhead(NONE) = 0/B = 0</span>. <span class="qed">‚àé</span></p>
</div>

<p>Implementation: <span class="m">GATE_CHECK(id, ‚Ä¶)</span> expands to <span class="m">((void)0)</span> when <span class="m">SECURITY_LEVEL = NONE</span>. Any C++ optimizer with dead code elimination removes this entirely.</p>

<h3>Cost Ordering</h3>

<p>From monotonicity of <span class="m">Œ±</span>:</p>

<div class="math-block"><code>l‚ÇÅ ‚äë l‚ÇÇ  ‚üπ  Overhead(l‚ÇÅ) ‚â§ Overhead(l‚ÇÇ)</code></div>

<p>Cost is monotonically non-decreasing with security level. You pay strictly for what you enable.</p>
</div>

<hr class="separator">

<!-- ¬ß5 -->
<div class="section">
<h2><span class="num">5</span> Sidecar Composition</h2>

<p>The three-thread sidecar model as a formal pipeline with verification completeness.</p>

<h3>Pipeline Model</h3>

<p>Three functions operating on program state <span class="m">s ‚àà S</span>:</p>

<div class="math-block"><code>FRONT : S ‚Üí S √ó Hint
LEAD  : S √ó Hint ‚Üí S‚Ä≤
REAR  : S √ó S‚Ä≤ ‚Üí { ‚úì, ‚úó }</code></div>

<p>Pipeline composition:</p>

<div class="math-block"><code>(h, s‚ÇÅ) = FRONT(s‚ÇÄ)              predict and prefetch
s‚ÇÇ      = LEAD(s‚ÇÅ, h)            authoritative execution
result  = REAR(s‚ÇÅ, s‚ÇÇ)           postcondition verification</code></div>

<p>FRONT is advisory. LEAD may ignore hints: <span class="m">‚àÄh : LEAD(s, h) = LEAD(s, ‚ä•)</span>. Hints improve performance, not correctness.</p>

<h3>REAR Verification Semantics</h3>

<p>REAR checks a set of postconditions <span class="m">Œ† = {œÄ‚ÇÅ, ‚Ä¶, œÄ‚Çñ}</span>:</p>

<div class="math-block"><code>REAR(s, s‚Ä≤) = ‚ãÄ·µ¢‚Çå‚ÇÅ·µè œÄ·µ¢(s, s‚Ä≤)</code></div>

<p>Where each <span class="m">œÄ·µ¢</span> is a gate postcondition:</p>

<div class="math-block"><code>œÄ_UAF(s, s‚Ä≤)  ‚â°  ‚àÄptr freed in s‚Üís‚Ä≤ : rc(ptr, s) = 0
œÄ_BOF(s, s‚Ä≤)  ‚â°  ‚àÄwrite(buf, i) in s‚Üís‚Ä≤ : i &lt; len(buf, s)
œÄ_RAC(s, s‚Ä≤)  ‚â°  ‚àÄ(c, u) in s‚Üís‚Ä≤ : val(r, t_c) = val(r, t_u)
œÄ_TYPE(s, s‚Ä≤) ‚â°  ‚àÄcast(ptr, œÑ) in s‚Üís‚Ä≤ : typeof(ptr, s) ‚äë œÑ</code></div>

<h3>Verification Completeness</h3>

<p><em>Definition.</em> REAR is complete for gate set <span class="m">ùí¢</span> iff:</p>

<div class="math-block"><code>‚àÄG ‚àà ùí¢,  ‚àÉœÄ ‚àà Œ† :  œÄ detects all violations of G</code></div>

<p>Formally:</p>

<div class="math-block"><code>‚àÄG ‚àà ùí¢, ‚àÄ(s, s‚Ä≤) :
    G would have returned 1 on some sub-state of s‚Üís‚Ä≤
    ‚üπ  REAR(s, s‚Ä≤) = ‚úó</code></div>

<div class="theorem">
  <div class="label">Defense in Depth Theorem</div>
  <p>Let <span class="m">Œì_pre</span> be gates checked before execution (LEAD). Let <span class="m">Œ†_post</span> be REAR postconditions. If <span class="m">Œ†_post</span> is complete for <span class="m">ùí¢</span>, then:</p>
</div>

<div class="math-block"><code>‚àÄ vulnerability v ‚àà ùí¢ :
    v is caught by Œì_pre      before damage
  ‚à® v is caught by Œ†_post     after execution, before propagation</code></div>

<p>No vulnerability in the gate taxonomy escapes both layers.</p>

<h3>Viewer-Specific Mapping</h3>

<div class="math-block"><code>FRONT  ‚Üí  Interest List / LOD System       h = prefetch_hints(s)
LEAD   ‚Üí  Main Loop (render, events, sim)  s‚Ä≤ = execute(s, h)
REAR   ‚Üí  Does not currently exist          result = verify(s, s‚Ä≤)</code></div>

<p>REAR catches what FRONT and LEAD miss: media plugin URL fetch postconditions, audio engine buffer TOCTOU violations, and object cache refcount consistency.</p>

<p>Composition guarantee:</p>

<div class="math-block"><code>REAR(LEAD(s, FRONT(s)))  ‚ä®  ‚ãÄ œÄ ‚àà Œ†</code></div>

<p>The rear sidecar, applied to the output of authoritative execution informed by front predictions, satisfies all postconditions in the verification set. When REAR returns ‚úó: gate fires retroactively, state is rolled back or quarantined, and the violation is logged with full <span class="m">(s, s‚Ä≤, œÄ)</span> context.</p>
</div>

<hr class="separator">

<!-- Notation -->
<div class="section">
<h2>Notation Reference</h2>

<div class="notation-grid">
  <div class="entry"><span class="sym">‚àÄ</span><span class="def">for all</span></div>
  <div class="entry"><span class="sym">‚àÉ</span><span class="def">there exists</span></div>
  <div class="entry"><span class="sym">‚àß</span><span class="def">logical AND</span></div>
  <div class="entry"><span class="sym">‚à®</span><span class="def">logical OR</span></div>
  <div class="entry"><span class="sym">¬¨</span><span class="def">logical NOT</span></div>
  <div class="entry"><span class="sym">‚üπ</span><span class="def">implies</span></div>
  <div class="entry"><span class="sym">‚ü∫</span><span class="def">if and only if</span></div>
  <div class="entry"><span class="sym">‚àà</span><span class="def">element of</span></div>
  <div class="entry"><span class="sym">‚äÜ</span><span class="def">subset of</span></div>
  <div class="entry"><span class="sym">‚äë</span><span class="def">subtype of</span></div>
  <div class="entry"><span class="sym">‚àÖ</span><span class="def">empty set</span></div>
  <div class="entry"><span class="sym">ùí´(X)</span><span class="def">power set of X</span></div>
  <div class="entry"><span class="sym">‚ãÄ</span><span class="def">conjunction</span></div>
  <div class="entry"><span class="sym">‚ä®</span><span class="def">satisfies / models</span></div>
  <div class="entry"><span class="sym">‚ñ°</span><span class="def">always (LTL)</span></div>
  <div class="entry"><span class="sym">‚óá</span><span class="def">eventually (LTL)</span></div>
  <div class="entry"><span class="sym">U</span><span class="def">until (LTL)</span></div>
  <div class="entry"><span class="sym">‚ä•</span><span class="def">bottom / undefined</span></div>
  <div class="entry"><span class="sym">‚ó¶</span><span class="def">function composition</span></div>
  <div class="entry"><span class="sym">‚à•</span><span class="def">parallel composition</span></div>
  <div class="entry"><span class="sym">‚ñ∑</span><span class="def">sequential gate comp</span></div>
  <div class="entry"><span class="sym">‚àé</span><span class="def">end of proof</span></div>
  <div class="entry"><span class="sym">‚äì</span><span class="def">lattice meet</span></div>
  <div class="entry"><span class="sym">‚äî</span><span class="def">lattice join</span></div>
  <div class="entry"><span class="sym">‚Ñï</span><span class="def">natural numbers</span></div>
  <div class="entry"><span class="sym">Œ©</span><span class="def">gate output domain</span></div>
  <div class="entry"><span class="sym">Œ±</span><span class="def">gate activation fn</span></div>
  <div class="entry"><span class="sym">Œ¥</span><span class="def">transition function</span></div>
  <div class="entry"><span class="sym">œÉ</span><span class="def">execution trace</span></div>
  <div class="entry"><span class="sym">Œò</span><span class="def">thread set</span></div>
  <div class="entry"><span class="sym">Œì</span><span class="def">gate set</span></div>
  <div class="entry"><span class="sym">Œ†</span><span class="def">postcondition set</span></div>
  <div class="entry"><span class="sym">œÜ</span><span class="def">gate predicate</span></div>
  <div class="entry"><span class="sym">œÄ</span><span class="def">postcondition predicate</span></div>
</div>
</div>

<footer class="page-footer">
  ¬© 2025 Euman Engineer ¬∑ CC BY-NC 4.0 ¬∑ <a href="https://github.com/opsec-ee/euman-scanner/blob/main/LICENSE">License</a>
</footer>

</div>
</body>
</html>

