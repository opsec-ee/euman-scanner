<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Formal Methods for Security Gate Patterns</title>
<link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,300;0,400;0,500;0,600;1,400&family=JetBrains+Mono:wght@400;500&family=Source+Sans+3:wght@300;400;500;600&display=swap" rel="stylesheet">
<style>
  :root {
    --ink: #1a1a1a;
    --ink-light: #4a4a4a;
    --ink-faint: #7a7a7a;
    --paper: #fdfbf7;
    --paper-warm: #f5f0e8;
    --accent: #8b2500;
    --accent-light: #c44d2a;
    --rule: #c8bfb0;
    --math-bg: #f8f5ef;
    --blue: #1a4a6e;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  html {
    font-size: 17px;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  body {
    font-family: 'Crimson Pro', Georgia, serif;
    color: var(--ink);
    background: var(--paper);
    line-height: 1.72;
    padding: 0;
  }

  .page {
    max-width: 740px;
    margin: 0 auto;
    padding: 4rem 2rem 6rem;
  }

  header {
    margin-bottom: 3.5rem;
    padding-bottom: 2rem;
    border-bottom: 2px solid var(--ink);
  }

  header h1 {
    font-family: 'Source Sans 3', Helvetica, sans-serif;
    font-weight: 600;
    font-size: 2rem;
    letter-spacing: -0.02em;
    line-height: 1.2;
    color: var(--ink);
    margin-bottom: 0.4rem;
  }

  header .subtitle {
    font-family: 'Source Sans 3', Helvetica, sans-serif;
    font-weight: 300;
    font-size: 1.15rem;
    color: var(--ink-light);
    margin-bottom: 1.6rem;
  }

  header .meta {
    font-family: 'Source Sans 3', Helvetica, sans-serif;
    font-size: 0.85rem;
    font-weight: 400;
    color: var(--ink-faint);
    line-height: 1.7;
  }

  header .meta a {
    color: var(--blue);
    text-decoration: none;
  }

  header .meta a:hover {
    text-decoration: underline;
  }

  .section {
    margin-bottom: 3rem;
  }

  h2 {
    font-family: 'Source Sans 3', Helvetica, sans-serif;
    font-weight: 600;
    font-size: 1.35rem;
    color: var(--ink);
    margin-bottom: 0.3rem;
    padding-top: 1rem;
    letter-spacing: -0.01em;
  }

  h2 .num {
    color: var(--accent);
    margin-right: 0.3em;
  }

  h3 {
    font-family: 'Source Sans 3', Helvetica, sans-serif;
    font-weight: 500;
    color: var(--ink-light);
    margin-top: 2rem;
    margin-bottom: 0.6rem;
    text-transform: uppercase;
    letter-spacing: 0.06em;
    font-size: 0.82rem;
  }

  p {
    margin-bottom: 0.9rem;
    text-align: justify;
    hyphens: auto;
  }

  .separator {
    border: none;
    border-top: 1px solid var(--rule);
    margin: 2.5rem 0;
  }

  .math-block {
    background: var(--math-bg);
    border-left: 3px solid var(--accent);
    padding: 1.2rem 1.5rem;
    margin: 1.2rem 0 1.4rem;
    border-radius: 0 4px 4px 0;
    overflow-x: auto;
  }

  .math-block code {
    font-family: 'JetBrains Mono', 'Menlo', monospace;
    font-size: 0.82rem;
    line-height: 1.85;
    color: var(--ink);
    white-space: pre;
    display: block;
  }

  .m {
    font-family: 'JetBrains Mono', 'Menlo', monospace;
    font-size: 0.88em;
    color: var(--ink);
    background: var(--math-bg);
    padding: 0.1em 0.3em;
    border-radius: 3px;
  }

  .theorem {
    background: var(--paper-warm);
    border: 1px solid var(--rule);
    border-radius: 4px;
    padding: 1.2rem 1.5rem;
    margin: 1.4rem 0;
  }

  .theorem .label {
    font-family: 'Source Sans 3', Helvetica, sans-serif;
    font-weight: 600;
    font-size: 0.82rem;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    color: var(--accent);
    margin-bottom: 0.5rem;
  }

  .theorem p {
    margin-bottom: 0.5rem;
  }

  .theorem p:last-child {
    margin-bottom: 0;
  }

  .qed {
    float: right;
    color: var(--accent);
    font-size: 0.9em;
  }

  .proof {
    margin: 0.8rem 0 1.2rem;
    padding-left: 1rem;
    border-left: 2px solid var(--rule);
  }

  .proof .tag {
    font-style: italic;
    color: var(--ink-light);
    font-size: 0.95rem;
  }

  .notation-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 0 2rem;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.8rem;
    line-height: 2;
    margin: 1rem 0;
    padding: 1rem 1.5rem;
    background: var(--math-bg);
    border-radius: 4px;
  }

  .notation-grid .entry {
    display: flex;
    gap: 0.8rem;
  }

  .notation-grid .sym {
    color: var(--accent);
    min-width: 2.2rem;
    text-align: center;
    flex-shrink: 0;
  }

  .notation-grid .def {
    color: var(--ink-light);
    font-family: 'Source Sans 3', sans-serif;
    font-size: 0.82rem;
  }

  footer.page-footer {
    margin-top: 3rem;
    padding-top: 1.5rem;
    border-top: 1px solid var(--rule);
    font-family: 'Source Sans 3', Helvetica, sans-serif;
    font-size: 0.8rem;
    color: var(--ink-faint);
    text-align: center;
  }

  footer.page-footer a {
    color: var(--blue);
    text-decoration: none;
  }

  footer.page-footer a:hover {
    text-decoration: underline;
  }

  @media print {
    body { background: white; font-size: 11pt; }
    .page { padding: 0; max-width: 100%; }
    .math-block { background: #f5f5f5; break-inside: avoid; }
    .theorem { break-inside: avoid; }
    header { break-after: avoid; }
  }

  @media (max-width: 600px) {
    html { font-size: 15px; }
    .page { padding: 2rem 1.2rem 3rem; }
    .notation-grid { grid-template-columns: 1fr; }
  }
</style>
</head>
<body>
<div class="page">

<header>
  <h1>Formal Methods for Security Gate Patterns</h1>
  <div class="subtitle">Mathematical Foundations for CVE-Surface Reduction</div>
  <div class="meta">
    Author: Euman Engineer<br>
    Contact: <a href="/cdn-cgi/l/email-protection#a2cdd2d1c7c18cc7c7e2d2cf8ccfc7"><span class="__cf_email__" data-cfemail="f09f80839593de9595b0809dde9d95">[email&#160;protected]</span></a><br>
    February 2025<br>
    License: CC BY-NC 4.0 â€” <a href="https://github.com/opsec-ee/euman-scanner/blob/main/LICENSE">https://github.com/opsec-ee/euman-scanner/blob/main/LICENSE</a>
  </div>
</header>

<!-- Â§1 -->
<div class="section">
<h2><span class="num">1</span> Gate Predicate Logic</h2>

<p>Let <span class="m">S</span> be the set of all observable program states. Let <span class="m">Î© = { 0, 1, X, Z }</span> be the 4-state gate output domain:</p>

<div class="math-block"><code>0 â‰¡ PASS       precondition satisfied
1 â‰¡ FAIL       violation detected
X â‰¡ UNKNOWN    insufficient information to decide
Z â‰¡ INVALID    gate inputs themselves are corrupt</code></div>

<p>A gate <span class="m">G</span> is a total function <span class="m">G : S â†’ Î©</span> satisfying the totality requirement <span class="m">âˆ€s âˆˆ S : G(s) âˆˆ Î©</span>. No gate may be partial. If the gate cannot evaluate, it returns X or Z â€” never âŠ¥.</p>

<h3>Gate Class Predicates</h3>

<p>Let <span class="m">ptr âˆˆ Addr</span>, <span class="m">rc âˆˆ â„•</span>, <span class="m">buf âˆˆ Byte*</span>, <span class="m">Ï„ âˆˆ Type</span>, <span class="m">t âˆˆ Time</span>.</p>

<div class="math-block"><code>Ï†_UAF(ptr)    â‰¡  ptr âˆˆ Live  âˆ§  rc(ptr) &gt; 0
Ï†_DF(ptr)     â‰¡  ptr âˆˆ Live  âˆ§  freed(ptr) = false
Ï†_NUL(ptr)    â‰¡  ptr â‰  0x0   âˆ§  page(ptr) âˆˆ Mapped
Ï†_BOF(buf, i) â‰¡  0 â‰¤ i &lt; len(buf)
Ï†_TYP(ptr, Ï„) â‰¡  typeof(ptr) âŠ‘ Ï„
Ï†_RAC(r, t)   â‰¡  Â¬âˆƒtâ€² âˆˆ (t_check, t_use) : mut(r, tâ€²)
Ï†_REF(rc)     â‰¡  rc &lt; RC_MAX  âˆ§  rc â‰¥ 0</code></div>

<p>Gate evaluation:</p>

<div class="math-block"><code>         â§ 0   if Ï†(s) = true
         âª 1   if Ï†(s) = false
G(s)  =  â¨ X   if Ï†(s) is undecidable at runtime
         âª Z   if inputs to Ï† are themselves corrupt
         â©</code></div>

<h3>Universal Invariant</h3>

<p>For any function <span class="m">f</span> protected by gate set <span class="m">Î“ = {Gâ‚, â€¦, Gâ‚™}</span>:</p>

<div class="math-block"><code>pre(f) â‰¡ â‹€áµ¢â‚Œâ‚â¿ (Gáµ¢(s) = 0)</code></div>

<p>Execution of <span class="m">f</span> proceeds if and only if all gates pass.</p>

<h3>Composition Algebra</h3>

<p>Gate conjunction, where <span class="m">â–·</span> denotes sequential check:</p>

<div class="math-block"><code>(Gâ‚ â–· Gâ‚‚)(s) = Gâ‚(s)    if Gâ‚(s) â‰  0
              = Gâ‚‚(s)    if Gâ‚(s) = 0

Short-circuit:
  Gâ‚(s) = 1  âŸ¹  (Gâ‚ â–· Gâ‚‚)(s) = 1      fail-fast
  Gâ‚(s) = Z  âŸ¹  (Gâ‚ â–· Gâ‚‚)(s) = Z      corruption propagates</code></div>

<p>Ordering on <span class="m">Î©</span> (failure lattice): <span class="m">Z &gt; 1 &gt; X &gt; 0</span>. For a gate vector <span class="m">Î“ = âŸ¨Gâ‚, â€¦, Gâ‚™âŸ©</span>:</p>

<div class="math-block"><code>Î“(s) = max(Gâ‚(s), Gâ‚‚(s), â€¦, Gâ‚™(s))</code></div>

<p>The worst violation dominates.</p>
</div>

<hr class="separator">

<!-- Â§2 -->
<div class="section">
<h2><span class="num">2</span> Object Lifetime State Machine</h2>

<p>Use-after-free and double-free are illegal transitions in the object lifecycle. Gates enforce transition guards.</p>

<h3>Definition</h3>

<div class="math-block"><code>M = (Q, Î£, Î´, qâ‚€, F)

Q  = { A, R, D, F, âŠ¥ }

  A = Allocated       memory obtained, not yet referenced
  R = Referenced      at least one live reference exists
  D = Dereferenced    all references released, rc = 0
  F = Freed           memory returned to allocator
  âŠ¥ = Error           illegal state â€” vulnerability triggered

qâ‚€ = A       initial state
F  = { F }   accepting states
âŠ¥ absorbing  no transitions out

Î£  = { alloc, ref, deref, free, access }</code></div>

<h3>Transition Function Î´ : Q Ã— Î£ â†’ Q</h3>

<div class="math-block"><code>Î´(A, ref)    = R
Î´(A, free)   = F
Î´(A, deref)  = âŠ¥
Î´(A, access) = âŠ¥

Î´(R, ref)    = R            rc â† rc + 1
Î´(R, deref)  = R            if rc âˆ’ 1 &gt; 0
Î´(R, deref)  = D            if rc âˆ’ 1 = 0
Î´(R, access) = R
Î´(R, free)   = âŠ¥            UAF-001 / CWE-416

Î´(D, free)   = F
Î´(D, ref)    = âŠ¥
Î´(D, deref)  = âŠ¥
Î´(D, access) = âŠ¥            UAF-001 / CWE-416

Î´(F, alloc)  = Aâ€²           reallocation
Î´(F, ref)    = âŠ¥            UAF-001 / CWE-416
Î´(F, access) = âŠ¥            UAF-001 / CWE-416
Î´(F, free)   = âŠ¥            DF-001  / CWE-415

Î´(âŠ¥, Ïƒ)     = âŠ¥            âˆ€Ïƒ âˆˆ Î£</code></div>

<h3>Gate as Transition Guard</h3>

<p>For any transition <span class="m">Î´(q, Ïƒ)</span> where <span class="m">Î´(q, Ïƒ)</span> could reach âŠ¥:</p>

<div class="math-block"><code>Î´_guarded(q, Ïƒ) = Î´(q, Ïƒ)     if G_Ïƒ(s) = 0
                = q             if G_Ïƒ(s) â‰  0     block and log</code></div>

<div class="theorem">
  <div class="label">Safety Theorem</div>
  <p>If every transition into âŠ¥ is guarded by a gate <span class="m">G</span> where <span class="m">G(s)</span> is evaluated before <span class="m">Î´</span>, then <span class="m">âˆ€</span> reachable states <span class="m">q : q â‰  âŠ¥</span>.</p>
</div>

<div class="proof">
  <p><span class="tag">Proof.</span> By induction on transition sequences. Base case: <span class="m">qâ‚€ = A â‰  âŠ¥</span>. Inductive step: assume <span class="m">qâ‚™ â‰  âŠ¥</span>. If <span class="m">Î´(qâ‚™, Ïƒ) = âŠ¥</span>, then <span class="m">G_Ïƒ</span> fires and the transition is blocked, so <span class="m">qâ‚™â‚Šâ‚ = qâ‚™ â‰  âŠ¥</span>. <span class="qed">âˆ</span></p>
</div>

<h3>Refcount Invariant</h3>

<p>For any object <span class="m">o</span> with reference count <span class="m">rc(o)</span>:</p>

<div class="math-block"><code>INV_REF(o)  â‰¡  0 â‰¤ rc(o) â‰¤ RC_MAX       where RC_MAX = 2Â³Â¹ âˆ’ 1

REF-001 gate enforces:

  pre(ref)   :  rc(o) &lt; RC_MAX            overflow prevention
  pre(deref) :  rc(o) &gt; 0                 underflow prevention
  pre(free)  :  rc(o) = 0  âˆ§  state(o) = D</code></div>

<h3>Bijective Contract</h3>

<p>For a function <span class="m">f : X â†’ Y</span> protected by gate <span class="m">G</span>:</p>

<div class="math-block"><code>{ G(s) = 0 }  f(x)  { G(sâ€²) = 0 }</code></div>

<p>If the gate passes before <span class="m">f</span> and <span class="m">f</span> preserves the invariant, then the gate passes after <span class="m">f</span>. This is the gate stability property â€” correct code cannot cause a gate to spontaneously transition from PASS to FAIL.</p>
</div>

<hr class="separator">

<!-- Â§3 -->
<div class="section">
<h2><span class="num">3</span> TOCTOU / RACE-001 Temporal Logic</h2>

<p>Race conditions require reasoning over time. We formalize using linear temporal logic over discrete execution steps.</p>

<h3>Temporal Model</h3>

<p>Let <span class="m">T = âŸ¨tâ‚€, tâ‚, tâ‚‚, â€¦âŸ©</span> be a discrete timeline of execution steps across all threads. For resource <span class="m">r</span>:</p>

<div class="math-block"><code>val(r, t) = value of r at time t
mut(r, t) = true iff r is mutated at time t</code></div>

<h3>TOCTOU Window</h3>

<p>A check-use pair <span class="m">(c, u)</span> on resource <span class="m">r</span> defines:</p>

<div class="math-block"><code>W(c, u) = { t âˆˆ T : t_c &lt; t &lt; t_u }</code></div>

<p>TOCTOU safety predicate:</p>

<div class="math-block"><code>SAFE(r, c, u)  â‰¡  âˆ€t âˆˆ W(c, u) : Â¬mut(r, t)</code></div>

<p>No mutation of <span class="m">r</span> occurs between check and use. The RACE-001 gate: <span class="m">Ï†_RAC(r, c, u) = SAFE(r, c, u)</span>.</p>

<h3>LTL Specification</h3>

<p>Let <span class="m">p</span> = resource <span class="m">r</span> has been checked, <span class="m">q</span> = resource <span class="m">r</span> is used, <span class="m">m</span> = resource <span class="m">r</span> is mutated.</p>

<p>Safety property:</p>

<div class="math-block"><code>â–¡(p â†’ (Â¬m U q))</code></div>

<p>Globally, if <span class="m">r</span> is checked, then <span class="m">r</span> is not mutated until <span class="m">r</span> is used.</p>

<p>Violation witness:</p>

<div class="math-block"><code>â—‡(p âˆ§ â—‡(m âˆ§ Â¬q âˆ§ â—‡q))</code></div>

<p>Eventually <span class="m">r</span> is checked, then eventually mutated before being used, and then used with stale data.</p>

<h3>Window Contraction Theorem</h3>

<p>Let <span class="m">n</span> be the number of interleaving points in window <span class="m">W(c, u)</span> and let <span class="m">f_mut(r)</span> be the per-step probability of mutation on resource <span class="m">r</span> by any thread <span class="m">Î¸â±¼ (j â‰  i)</span>.</p>

<div class="theorem">
  <div class="label">Window Contraction Theorem</div>
  <p>The probability of a TOCTOU violation on resource <span class="m">r</span> over window <span class="m">W(c, u)</span> is bounded by:</p>
</div>

<div class="math-block"><code>P(race) = 1 âˆ’ (1 âˆ’ f_mut(r))â¿

where n = |W(c, u)| = t_u âˆ’ t_c     interleaving points in window</code></div>

<p>For small <span class="m">f_mut(r)</span>, the first-order approximation gives the linear bound:</p>

<div class="math-block"><code>P(race) â‰ˆ n Ã— f_mut(r)    when f_mut(r) â‰ª 1</code></div>

<div class="proof">
  <p><span class="tag">Proof.</span> At each interleaving point <span class="m">t âˆˆ W(c, u)</span>, the probability that no mutation occurs is <span class="m">(1 âˆ’ f_mut(r))</span>. The <span class="m">n</span> points are independent scheduling decisions. Therefore <span class="m">P(safe) = (1 âˆ’ f_mut(r))â¿</span> and <span class="m">P(race) = 1 âˆ’ P(safe) = 1 âˆ’ (1 âˆ’ f_mut(r))â¿</span>. By Bernoulli's inequality, for <span class="m">f_mut(r) â‰ª 1</span>: <span class="m">(1 âˆ’ f_mut(r))â¿ â‰ˆ 1 âˆ’ n Ã— f_mut(r)</span>, yielding the linear bound. <span class="qed">âˆ</span></p>
</div>

<p><strong>Corollary.</strong> <span class="m">P(race)</span> is monotonically increasing in both <span class="m">n</span> and <span class="m">f_mut(r)</span>. Reducing either reduces vulnerability exposure.</p>

<p>Mitigation strategies follow directly:</p>

<div class="math-block"><code>Strategy 1:  Minimize n              contract W by checking immediately before use
             n â†’ 1  âŸ¹  P(race) â†’ f_mut(r)

Strategy 2:  Eliminate f_mut         hold mutex on r during W
             f_mut â†’ 0  âŸ¹  P(race) â†’ 0

Strategy 3:  REAR verification       detect violations post-hoc
             does not reduce P(race), but guarantees detection:
             REAR asserts val(r, t_c) = val(r, t_u)
             violation âŸ¹ RACE-001 fires retroactively</code></div>

<p>Strategies 1 and 2 reduce <span class="m">P(race)</span> directly. Strategy 3 accepts the race window but guarantees no undetected exploitation â€” the REAR sidecar provides the completeness bound.</p>

<h3>Interleaving Semantics</h3>

<p>Let <span class="m">Î˜ = {Î¸â‚, Î¸â‚‚, â€¦, Î¸â‚™}</span> be the set of active threads. An execution trace <span class="m">Ïƒ</span> is an interleaving <span class="m">Ïƒ âˆˆ shuffle(Î¸â‚, Î¸â‚‚, â€¦, Î¸â‚™)</span>.</p>

<p>RACE-001 is violated iff:</p>

<div class="math-block"><code>âˆƒÏƒ âˆˆ Interleavings(Î˜) :
    âˆƒ(c, u) âˆˆ Ïƒ|Î¸áµ¢,  âˆƒm âˆˆ Ïƒ|Î¸â±¼  (i â‰  j) :
        t_c &lt; t_m &lt; t_u  âˆ§  target(m) = target(c)</code></div>

<p>There exists an interleaving where another thread mutates the checked resource before the checking thread uses it.</p>

<p>Gate coverage: a gate set <span class="m">Î“</span> is RACE-COMPLETE for resource set <span class="m">R</span> iff:</p>

<div class="math-block"><code>âˆ€r âˆˆ R, âˆ€(c, u) on r :  âˆƒG âˆˆ Î“ : G validates SAFE(r, c, u)</code></div>
</div>

<hr class="separator">

<!-- Â§4 -->
<div class="section">
<h2><span class="num">4</span> Overhead Cost Model</h2>

<p>Security levels form a lattice. Gate activation is monotonic over this lattice. The compile-out property guarantees zero cost at the bottom.</p>

<h3>Security Level Lattice</h3>

<p>Let <span class="m">L = { NONE, BASIC, STANDARD, PARANOID }</span> ordered by âŠ‘ :</p>

<div class="math-block"><code>NONE  âŠ‘  BASIC  âŠ‘  STANDARD  âŠ‘  PARANOID</code></div>

<p><span class="m">L</span> forms a total order and therefore a lattice with <span class="m">âŠ“ = min</span>, <span class="m">âŠ” = max</span>.</p>

<h3>Gate Activation Function</h3>

<p>Let <span class="m">ğ’¢ = {UAF, DF, NULL, BOF, TYPE, RACE, REF}</span> be all gate classes. Define activation <span class="m">Î± : L â†’ ğ’«(ğ’¢)</span> :</p>

<div class="math-block"><code>Î±(NONE)     = âˆ…
Î±(BASIC)    = { REF, TYPE }
Î±(STANDARD) = { REF, TYPE, BOF, NULL }
Î±(PARANOID) = ğ’¢                          all gates plus canaries</code></div>

<p>Monotonicity: <span class="m">lâ‚ âŠ‘ lâ‚‚ âŸ¹ Î±(lâ‚) âŠ† Î±(lâ‚‚)</span>. Higher security levels only add gates, never remove them.</p>

<h3>Cost Function</h3>

<p>Each gate <span class="m">Gáµ¢</span> has a per-invocation cost <span class="m">cáµ¢</span> measured in branch-on-condition cycles. For a function <span class="m">f</span> invoked with frequency <span class="m">fáµ¢</span> calls/sec, guarded by gate set <span class="m">Î“_f âŠ† ğ’¢</span> :</p>

<div class="math-block"><code>Cost(f, l) = fáµ¢  Ã—  Î£{ câ±¼ : Gâ±¼ âˆˆ Î“_f âˆ© Î±(l) }

Overhead(l) = Î£_f Cost(f, l)  /  Baseline</code></div>

<p>Measured bounds:</p>

<div class="math-block"><code>Overhead(NONE)      =  0%         proven below
Overhead(BASIC)     â‰ˆ  5%         REF + TYPE only
Overhead(STANDARD)  â‰ˆ 10%         plus bounds checks
Overhead(PARANOID)  â‰ˆ 20%         all gates plus memory canaries</code></div>

<div class="theorem">
  <div class="label">Compile-Out Theorem</div>
  <p><strong>Claim:</strong> <span class="m">Overhead(NONE) = 0</span> exactly.</p>
</div>

<div class="proof">
  <p><span class="tag">Proof.</span> <span class="m">Î±(NONE) = âˆ…</span> by definition. <span class="m">âŸ¹ âˆ€f : Î“_f âˆ© Î±(NONE) = âˆ…</span> (intersection with âˆ…). <span class="m">âŸ¹ âˆ€f : Cost(f, NONE) = 0</span> (empty sum). <span class="m">âŸ¹ Overhead(NONE) = 0/B = 0</span>. <span class="qed">âˆ</span></p>
</div>

<p>Implementation: <span class="m">GATE_CHECK(id, â€¦)</span> expands to <span class="m">((void)0)</span> when <span class="m">SECURITY_LEVEL = NONE</span>. Any C++ optimizer with dead code elimination removes this entirely.</p>

<h3>Cost Ordering</h3>

<p>From monotonicity of <span class="m">Î±</span>:</p>

<div class="math-block"><code>lâ‚ âŠ‘ lâ‚‚  âŸ¹  Overhead(lâ‚) â‰¤ Overhead(lâ‚‚)</code></div>

<p>Cost is monotonically non-decreasing with security level. You pay strictly for what you enable.</p>
</div>

<hr class="separator">

<!-- Â§5 -->
<div class="section">
<h2><span class="num">5</span> Sidecar Composition</h2>

<p>The three-thread sidecar model as a formal pipeline with verification completeness.</p>

<h3>Pipeline Model</h3>

<p>Three functions operating on program state <span class="m">s âˆˆ S</span>:</p>

<div class="math-block"><code>FRONT : S â†’ S Ã— Hint
LEAD  : S Ã— Hint â†’ Sâ€²
REAR  : S Ã— Sâ€² â†’ { âœ“, âœ— }</code></div>

<p>Pipeline composition:</p>

<div class="math-block"><code>(h, sâ‚) = FRONT(sâ‚€)              predict and prefetch
sâ‚‚      = LEAD(sâ‚, h)            authoritative execution
result  = REAR(sâ‚, sâ‚‚)           postcondition verification</code></div>

<p>FRONT is advisory. LEAD may ignore hints: <span class="m">âˆ€h : LEAD(s, h) = LEAD(s, âŠ¥)</span>. Hints improve performance, not correctness.</p>

<h3>REAR Verification Semantics</h3>

<p>REAR checks a set of postconditions <span class="m">Î  = {Ï€â‚, â€¦, Ï€â‚–}</span>:</p>

<div class="math-block"><code>REAR(s, sâ€²) = â‹€áµ¢â‚Œâ‚áµ Ï€áµ¢(s, sâ€²)</code></div>

<p>Where each <span class="m">Ï€áµ¢</span> is a gate postcondition:</p>

<div class="math-block"><code>Ï€_UAF(s, sâ€²)  â‰¡  âˆ€ptr freed in sâ†’sâ€² : rc(ptr, s) = 0
Ï€_BOF(s, sâ€²)  â‰¡  âˆ€write(buf, i) in sâ†’sâ€² : i &lt; len(buf, s)
Ï€_RAC(s, sâ€²)  â‰¡  âˆ€(c, u) in sâ†’sâ€² : val(r, t_c) = val(r, t_u)
Ï€_TYPE(s, sâ€²) â‰¡  âˆ€cast(ptr, Ï„) in sâ†’sâ€² : typeof(ptr, s) âŠ‘ Ï„</code></div>

<h3>Verification Completeness</h3>

<p><em>Definition.</em> REAR is complete for gate set <span class="m">ğ’¢</span> iff:</p>

<div class="math-block"><code>âˆ€G âˆˆ ğ’¢,  âˆƒÏ€ âˆˆ Î  :  Ï€ detects all violations of G</code></div>

<p>Formally:</p>

<div class="math-block"><code>âˆ€G âˆˆ ğ’¢, âˆ€(s, sâ€²) :
    G would have returned 1 on some sub-state of sâ†’sâ€²
    âŸ¹  REAR(s, sâ€²) = âœ—</code></div>

<div class="theorem">
  <div class="label">Defense in Depth Theorem</div>
  <p>Let <span class="m">Î“_pre</span> be gates checked before execution (LEAD). Let <span class="m">Î _post</span> be REAR postconditions. If <span class="m">Î _post</span> is complete for <span class="m">ğ’¢</span>, then:</p>
</div>

<div class="math-block"><code>âˆ€ vulnerability v âˆˆ ğ’¢ :
    v is caught by Î“_pre      before damage
  âˆ¨ v is caught by Î _post     after execution, before propagation</code></div>

<p>No vulnerability in the gate taxonomy escapes both layers.</p>

<h3>Viewer-Specific Mapping</h3>

<div class="math-block"><code>FRONT  â†’  Interest List / LOD System       h = prefetch_hints(s)
LEAD   â†’  Main Loop (render, events, sim)  sâ€² = execute(s, h)
REAR   â†’  Does not currently exist          result = verify(s, sâ€²)</code></div>

<p>REAR catches what FRONT and LEAD miss: media plugin URL fetch postconditions, audio engine buffer TOCTOU violations, and object cache refcount consistency.</p>

<p>Composition guarantee:</p>

<div class="math-block"><code>REAR(LEAD(s, FRONT(s)))  âŠ¨  â‹€ Ï€ âˆˆ Î </code></div>

<p>The rear sidecar, applied to the output of authoritative execution informed by front predictions, satisfies all postconditions in the verification set. When REAR returns âœ—: gate fires retroactively, state is rolled back or quarantined, and the violation is logged with full <span class="m">(s, sâ€², Ï€)</span> context.</p>
</div>

<hr class="separator">

<!-- Notation -->
<div class="section">
<h2>Notation Reference</h2>

<div class="notation-grid">
  <div class="entry"><span class="sym">âˆ€</span><span class="def">for all</span></div>
  <div class="entry"><span class="sym">âˆƒ</span><span class="def">there exists</span></div>
  <div class="entry"><span class="sym">âˆ§</span><span class="def">logical AND</span></div>
  <div class="entry"><span class="sym">âˆ¨</span><span class="def">logical OR</span></div>
  <div class="entry"><span class="sym">Â¬</span><span class="def">logical NOT</span></div>
  <div class="entry"><span class="sym">âŸ¹</span><span class="def">implies</span></div>
  <div class="entry"><span class="sym">âŸº</span><span class="def">if and only if</span></div>
  <div class="entry"><span class="sym">âˆˆ</span><span class="def">element of</span></div>
  <div class="entry"><span class="sym">âŠ†</span><span class="def">subset of</span></div>
  <div class="entry"><span class="sym">âŠ‘</span><span class="def">subtype of</span></div>
  <div class="entry"><span class="sym">âˆ…</span><span class="def">empty set</span></div>
  <div class="entry"><span class="sym">ğ’«(X)</span><span class="def">power set of X</span></div>
  <div class="entry"><span class="sym">â‹€</span><span class="def">conjunction</span></div>
  <div class="entry"><span class="sym">âŠ¨</span><span class="def">satisfies / models</span></div>
  <div class="entry"><span class="sym">â–¡</span><span class="def">always (LTL)</span></div>
  <div class="entry"><span class="sym">â—‡</span><span class="def">eventually (LTL)</span></div>
  <div class="entry"><span class="sym">U</span><span class="def">until (LTL)</span></div>
  <div class="entry"><span class="sym">âŠ¥</span><span class="def">bottom / undefined</span></div>
  <div class="entry"><span class="sym">â—¦</span><span class="def">function composition</span></div>
  <div class="entry"><span class="sym">âˆ¥</span><span class="def">parallel composition</span></div>
  <div class="entry"><span class="sym">â–·</span><span class="def">sequential gate comp</span></div>
  <div class="entry"><span class="sym">âˆ</span><span class="def">end of proof</span></div>
  <div class="entry"><span class="sym">âŠ“</span><span class="def">lattice meet</span></div>
  <div class="entry"><span class="sym">âŠ”</span><span class="def">lattice join</span></div>
  <div class="entry"><span class="sym">â„•</span><span class="def">natural numbers</span></div>
  <div class="entry"><span class="sym">Î©</span><span class="def">gate output domain</span></div>
  <div class="entry"><span class="sym">Î±</span><span class="def">gate activation fn</span></div>
  <div class="entry"><span class="sym">Î´</span><span class="def">transition function</span></div>
  <div class="entry"><span class="sym">Ïƒ</span><span class="def">execution trace</span></div>
  <div class="entry"><span class="sym">Î˜</span><span class="def">thread set</span></div>
  <div class="entry"><span class="sym">Î“</span><span class="def">gate set</span></div>
  <div class="entry"><span class="sym">Î </span><span class="def">postcondition set</span></div>
  <div class="entry"><span class="sym">Ï†</span><span class="def">gate predicate</span></div>
  <div class="entry"><span class="sym">Ï€</span><span class="def">postcondition predicate</span></div>
</div>
</div>

<footer class="page-footer">
  Â© 2025 Euman Engineer Â· CC BY-N
